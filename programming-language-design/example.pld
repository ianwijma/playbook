# A namespace can be defined across multiple files, this allows for organising methods
Namespace App\Example;

# Importing, exported methods, structures and Constants. This needs to be below the Namespace, before declaring anything else.
Import Std\String\{split,toLowers,toString};
Import Std\Crypto\{encode};
Import Std\Out\{writeLine};
Import Std\Array\{allocateArray,forEach,count};

# Constants
Constant String SOME_API_KEY = 'some-api-key-value';

# Constants can be exported
Export Constant Integer MINIMUM_SPEED = 30;

# Basic variables, by default not changeable
Char firstLetter = 'a';
String myVar = 'MyString';
Integer width = 10;
Float percentage = 1.23;
Double geoLocation = 1.23;
Boolean canDrinkAlcohol = true;

# Type is optional for basic variable declarations
age = 35
height = 10
isFlying = true

# a new scope like a method is a clean one, no variable leaking without explicit passing variables around
Constant String SOME_CONSTANT_STRING = 'Hello World';
String joke = '*Insert Joke*';
Method()=>String writeComedianJoke = () => {
    # Joke is not available here
    writeLine(joke);

    # Constants are available here
    writeLine(SOME_CONSTANT_STRING);

    String comedian = 'John Doe';

    return comedian;
}
writeLine(comedian); # Comedian is not available here
writeLine(writeComedianJoke()); # Comedian is written here


# Variable reassignment
Dynamic String name = 'John';
name = 'Doe';

# Enums
Enum RGB = {
    RED
    GREEN
    BLUE
}

# Enums default to numbers (1,2,3), but strings are also usable
Enum OrderStatus = {
    NEW = 'new'
    PAID = 'paid'
    SEND = 'send'
    DELIVERED = 'delivered'
}

# Enums can also be on one line, but coma seperated
Enum UserRoles = { ADMIN, CUSTOMER, GUEST }

# Enums can be exported
Export Enum ImageTypes = {
    GIF
    JPG
    JPEG
    PNG
}

# Enum can be used as a type
Method(ImageTypes)=>Boolean validImageType = (type) => {
    return type == ImageTypes.GIF;
}
Boolean isValid = validImageType(ImageTypes.JPG);

# Arrays
String[] todos = ['Clean the bathroom', 'Vacuum the living room'];

# Fixed length array
Integer[13] counter = [];
writeLine(count(counter)); # 13

# Destruct arrays
[String firstTodo] = todos;

# Structures
Structure Address = {
    String firstname
    String lastname
    Structure coordinates = {
        Float North
        Float east
    }
}

# Usage of structures
Address deliveryAddress = {
    firstname = ''
    lastname = ''
    coordinates = {
        north = 12.345678
        east = 12.345678
    }
}

# Deconstruct structures
{ String firstname, String lastname } = deliveryAddress;
{ Float north, Float easy } = deliveryAddress.coordinates

# Structures can be exported
Export Structure Person = {
    String firstName
    String lastName
    Int age
}

# One line method
Method(String)=>String[] pathSplit = (inputVar) => split('/', inputVar);

# Multi line method
Export Method=>String pathLowerSplit = (String inputVar) => {
    String lowerVar = toLowers(inputVar);
    return split('/', lowerVar);
}

# Exporting
Export Method()=>String dankMemes = () => encode(SOME_API_KEY, 'base64');

# Overloaded methods with the same name, but different signature
Method(String)=>Void save = (value) => saveAsString(value);
Method(Integer)=>Void save = (value) => saveAsInt(value);

save("Hello"); # Invokes saveAsString
save(42);      # Invokes saveAsInt


# Semicolon is optional, but required if you want to separate methods
Integer age = 30; Integer averageAge = 45
String name = 'Ian'

# String templating
Integer age = 30;
String myAge = "My age is: {age}";
String emptyTemplate = "This also works";
String escaping = "I just want \{brackets\} here.";

# Also executes methods, but they need to return an String
Method()=>String getAge = () => toString(age);
String myAgeByMethod = "My age is: {getAge()}";

# If Statement
Method(Integer)=>void ifStatement = (age) => {
    if (age > 18) {
        Boolean canDrink = true
    } else {
        Boolean canDrink = false
    }
}

# Loops using while
Method(Integer, String)=>void writeLinesUsingWhile = (amount, message) => {
    Dynamic Integer i = 0;
    while (i < amount) {
        writeLine(message);
        i = i + 1;
    }
}

# Loops using method
Method(Integer, String)=>void writeLinesUsingForEach = (amount, message) => {
    Boolean[amount] booleanArray = [];
    forEach(booleanArray, () => writeLine(message));
}

# Memory management, unless exported memory is cleared once the scope has ended.
Method(String, String, Integer)=>Person getNewPerson = (first, last, age) => {
    Person newPerson = {
        firstname = first
        lastname = last
        age = age
    }

    return newPerson;
} # newPerson variable is cleared from memory

# Match control flow
Enum Operation = {
    ADD
    SUBTRACT
    MULTIPLY
    DIVIDE
}

Method(Operation, Integer, Integer)=>Result(Integer, String) performOperation = (operation, a, b) => {
    Match operation {
        Operation.ADD => Ok(a + b);
        Operation.SUBTRACT => Ok(a - b);
        Operation.MULTIPLY => Ok(a * b);
        Operation.DIVIDE => {
            if (b != 0) {
                Ok(a / b);
            } else {
                Err("Division by zero");
            }
        }
    }
}

Method(Result(Integer, String)) printResult = (result) => {
    Match result {
        Ok(value) => writeLine("Result: {value}")
        Err(error) => writeLine("Error: {error}")
    }
}

Result(Integer, String) result1 = performOperation(Operation.ADD, 5, 3);
Result(Integer, String) result2 = performOperation(Operation.MULTIPLY, 5, 2);
Result(Integer, String) result3 = performOperation(Operation.DIVIDE, 10, 0);

printResult(result1); # Result: 8
printResult(result2); # Result: 10
printResult(result3); # Error: Division by zero


# error handling
Method(String)=>Result(Integer, String) parseAndReturnInteger = (input) => {
    try {
        Integer number = Integer.parse(input);
        return Ok(number);
    } catch (Exception e) {
        return Err("Error parsing integer");
    }
}

Result(Integer, String) result1 = parseAndReturnInteger("123");   # Returns Ok(123)
Result(Integer, String) result2 = parseAndReturnInteger("abc");   # Returns Err("Error parsing integer")

Match result1 {
    Ok(value) => writeLine("Parsed integer: {value}"),
    Err(error) => writeLine("Error: {error}")
}

Match result2 {
    Ok(value) => writeLine("Parsed integer: {value}"),
    Err(error) => writeLine("Error: {error}")
}
